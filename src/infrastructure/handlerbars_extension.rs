//! # Contain some helper of the handlebars

use handlebars::{Handlebars, Helper, RenderContext, RenderError, Renderable};
use serde::Serialize;
use std::collections::HashMap;
/// # Render the json Format of the object.
///
/// A helper for handlebars
pub fn json_helper(h: &Helper, _: &Handlebars, rc: &mut RenderContext) -> Result<(), RenderError> {
    if let Some(param) = h.param(0) {
        let json = param.value();
        rc.writer.write(&json.to_string().into_bytes()).is_ok();
    }
    Ok(())
}

/// # Output content to file.
///
/// A helper for handlebars.
pub fn file_helper(h: &Helper, r: &Handlebars, rc: &mut RenderContext) -> Result<(), RenderError> {
    let template = h.template();
    let file_path: String = h.params()
        .iter()
        .flat_map(|x| {
            if let Some(temp) = x.value().as_str() {
                temp.chars()
            } else {
                "".chars()
            }
        })
        .collect();

    match template {
        Some(t) => {
            t.render(r, rc).unwrap();
        }
        None => {}
    }
    rc.writer
        .write_all(&file_path.to_string().into_bytes())
        .is_ok();
    Ok(())
}

pub fn pagination_helper(
    h: &Helper,
    r: &Handlebars,
    rc: &mut RenderContext,
) -> Result<(), RenderError> {
    let template = h.template();
    let file_path: String = h.params()
        .iter()
        .flat_map(|x| {
            if let Some(temp) = x.value().as_str() {
                temp.chars()
            } else {
                "".chars()
            }
        })
        .collect();

    match template {
        Some(t) => {
            t.render(r, rc).unwrap();
        }
        None => {}
    }
    rc.writer
        .write_all(&file_path.to_string().into_bytes())
        .is_ok();
    Ok(())
}
// /// # Html generated by Markdown.
// ///
// /// A helper for handlebars.
// pub fn markdown_helper(
//     _: &Context,
//     h: &Helper,
//     _: &Handlebars,
//     rc: &mut RenderContext,
// ) -> Result<(), RenderError> {
//     if let Some(param) = h.param(0) {
//         let json = param.value();
//         let html: String = format!("{}", Markdown(&json.as_string().unwrap()));
//         rc.writer.write(&html.into_bytes()).is_ok();
//     }
//     Ok(())
// }

pub trait HandlebarsExtension {
    fn render_with_file<T>(
        &mut self,
        name: &str,
        data: &T,
    ) -> Result<HashMap<String, String>, RenderError>
    where
        T: Serialize;
    fn render_template_with_file<T>(
        &mut self,
        template_string: &str,
        data: &T,
    ) -> Result<HashMap<String, String>, RenderError>
    where
        T: Serialize;
}

impl HandlebarsExtension for Handlebars {
    fn render_with_file<T>(
        &mut self,
        name: &str,
        data: &T,
    ) -> Result<HashMap<String, String>, RenderError>
    where
        T: Serialize,
    {
        if self.get_template("file") == None {
            self.register_helper("file", Box::new(file_helper));
        }

        let mut write = writer::TemplateWriter::new();
        self.render_to_write(name, data, &mut write).unwrap();
        return Ok(write.map);
    }

    fn render_template_with_file<T>(
        &mut self,
        template_string: &str,
        data: &T,
    ) -> Result<HashMap<String, String>, RenderError>
    where
        T: Serialize,
    {
        if self.get_template("file") == None {
            self.register_helper("file", Box::new(file_helper));
        }
        let mut write = writer::TemplateWriter::new();
        self.render_template_to_write(template_string, data, &mut write)
            .unwrap();
        return Ok(write.map);
    }
}

mod writer {
    use std::io::prelude::*;
    use std::io::Result;
    use std::collections::HashMap;
    pub struct TemplateWriter {
        pub map: HashMap<String, String>,
        pub buffer: Vec<u8>,
        pub indexes: Vec<usize>,
    }
    impl TemplateWriter {
        pub fn new() -> TemplateWriter {
            TemplateWriter {
                map: HashMap::new(),
                buffer: vec![],
                indexes: vec![],
            }
        }
    }

    impl Write for TemplateWriter {
        fn write(&mut self, buf: &[u8]) -> Result<usize> {
            self.buffer.extend_from_slice(buf);

            return Ok(buf.len());
        }

        fn flush(&mut self) -> Result<()> {
            return Ok(());
        }

        fn write_all(&mut self, buf: &[u8]) -> Result<()> {
            let mut buffer: Vec<u8> = vec![];
            buffer.extend_from_slice(buf);
            let path = String::from_utf8(buffer).unwrap_or(String::new());
            self.map.insert(
                path.clone(),
                String::from_utf8(self.buffer.clone()).unwrap_or(String::new()),
            );
            self.buffer = vec![];

            return Ok(());
        }
    }
}
